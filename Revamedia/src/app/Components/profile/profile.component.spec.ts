import { HttpErrorResponse } from '@angular/common/http';
import { ComponentFixture, TestBed } from '@angular/core/testing';
import { of, throwError } from 'rxjs';
import { UserService } from 'src/app/Shared/services/user-service/user.service';

import { ProfileComponent } from './profile.component';

describe('ProfileComponent', () => {
  let component: ProfileComponent; // <-- Reference to component class (access/change properties, call methods, etc.)
  let fixture: ComponentFixture<ProfileComponent>; // <-- This is the parent of the component class (contains component, debugElement(html template), etc.). We don't need to test html template bindings.
  // Mock UserService (getUser method)
  // Second param is an array of method identifiers you wish to instantiate as spies.
  // We are only using 'getUser' in this component
  let userServiceSpy: { getUser: jasmine.Spy };

  // Spin up Test Module (Notice this is async because of line 24)
  beforeEach(async () => {
    // Initialize the spy before each test & before we inject it in our test module. (If we don't do this some stats that are kept track of, i.e. method invocation count will not be reset each test)
    userServiceSpy = jasmine.createSpyObj('UserService', ['getUser']);

    await TestBed.configureTestingModule({
      declarations: [ ProfileComponent ],
      // When the component tries to grab the UserService it will be grabbing our spy object instead
      providers: [
        { provide: UserService, useValue: userServiceSpy }
      ]
    })
    .compileComponents();
  });

  //Test environment is set up. Additional before each statements here.
  beforeEach(() => {
    fixture = TestBed.createComponent(ProfileComponent);
    component = fixture.componentInstance;
    // ngOnInit() is executed here (line below). Mock any functionality located within that method before this
    // fixture.detectChanges(); // <-- If you were integration testing the html template this would update bindings in html to reflect component values
  });

  // Define Test
  it('should create', () => {
    // Smoke test (Automatically generated by cli)
    expect(component).toBeTruthy();
  });

  // Define Test
  it('closeModal should remove "openScreen" class from screen element', () => {
    // Arrange
    // Parameter passed into method on act
    const modalTypeToPassIn: string = "test";
    // HTMl element
    const screenElement = document.createElement('div');

    // Return element from method ( when(document.getElementById(any())).thenReturn(screenElement) )
    spyOn(document, 'getElementById').and.returnValue(screenElement);
    // When screenElement.classList.remove() is called, invoke our supplied function instead (here do nothing)
    spyOn(screenElement.classList, 'remove').and.callFake(function() {});

    // Act
    component.closeModal(modalTypeToPassIn);

    // Assert
    // Notice in expect it is a reference to the mocked method, it is not invoked (No "()")
    expect(document.getElementById).toHaveBeenCalledWith('screen');
    expect(screenElement.classList.remove).toHaveBeenCalledWith('openScreen');
  });

  // Define Test
  it('closeModal should remove "openModal" class from modal element', () => {
    // Arrange
    // Parameter passed into method on act
    const modalTypeToPassIn: string = "test";
    // HTMl element
    const modalElement = document.createElement('div');

    // Return element from method ( when(document.getElementById(any())).thenReturn(modalElement) )
    spyOn(document, 'getElementById').and.returnValue(modalElement);
    // When screenElement.classList.remove() is called, invoke our supplied function instead (here do nothing)
    spyOn(modalElement.classList, 'remove').and.callFake(function() {});

    // Act
    component.closeModal(modalTypeToPassIn);

    // Assert
    // Notice in expect it is a reference to the spied on method, it is not invoked (No "()")
    expect(document.getElementById).toHaveBeenCalledWith('test-modal');
    expect(modalElement.classList.remove).toHaveBeenCalledWith('openModal');
  });

  it('openModal should add "openScreen" class to screen element', () => {
    // Arrange
    const modalTypeToPassIn: string = "test";
    const dataToPassIn: any = "testData";
    const screen = document.createElement('div');

    spyOn(document, 'getElementById').and.returnValue(screen);
    spyOn(screen.classList, 'add').and.callFake(function() {});

    // Act
    component.openModal(modalTypeToPassIn, dataToPassIn);

    // Assert
    expect(document.getElementById).toHaveBeenCalledWith('screen');
    expect(screen.classList.add).toHaveBeenCalledWith('openScreen');
  });

  it('openModal should add "openModal" class to modal element', () => {
    // Arrange
    const modalTypeToPassIn: string = "test";
    const dataToPassIn: any = "testData";
    const modal = document.createElement('div');

    spyOn(document, 'getElementById').and.returnValue(modal);
    spyOn(modal.classList, 'add').and.callFake(function() {});

    // Act
    component.openModal(modalTypeToPassIn, dataToPassIn);

    // Assert
    expect(document.getElementById).toHaveBeenCalledWith('test-modal');
    expect(modal.classList.add).toHaveBeenCalledWith('openModal');
  });

  // Define Test
  it('ngOnInit should call getCurrentUserData', () => {
    // Arrange
    // When userService.getUser method is called return empty observable
    userServiceSpy.getUser.and.returnValue(of());

    // Act
    // Call ngOnInit()
    component.ngOnInit();

    // Assert
    expect(userServiceSpy.getUser).toHaveBeenCalledTimes(1);
  });

  // Define Test
  it('getCurrentUserData should update component user on success', () => {
    // Arrange
    // User that will be returned
    const user = {
      userId: 1,
      firstName: "John",
      lastName: "Doe"
    };
    // When userService.getUser method is called return our user as observable so that it can be subscribed to
    userServiceSpy.getUser.and.returnValue(of(user));

    // Act
    component.getCurrentUserData();

    // Assert
    expect(component.user).toEqual(user);
  });

  // Define Test
  it('getCurrentUserData should log error on fail', () => {
    // Arrange
    // HttpErrorResponse to throw (I just included message cause that's all the component is using)
    const customHttpError: Partial<HttpErrorResponse> = {
      message: "This is the error message"
    };
    // When userService.getUser is called this will instead RETURN AN OBSERVABLE IN WHICH WILL THEN ERROR ON SUBSCRIBE with specified error (Notice 'throwError()' is a rxjs method. If you want to just throw an error from a method replace '.returnValue()' with '.throwError()')
    userServiceSpy.getUser.and.returnValue(throwError(() => customHttpError));
    // Spy on console.log so we can assert that it was called
    spyOn(console, 'log');

    // Act
    component.getCurrentUserData();

    // Assert
    expect(console.log).toHaveBeenCalledWith(customHttpError.message)
  });
});
