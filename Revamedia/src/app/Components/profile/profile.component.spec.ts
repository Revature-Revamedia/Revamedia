import { HttpErrorResponse } from '@angular/common/http';
import { ComponentFixture, fakeAsync, TestBed, tick } from '@angular/core/testing';
import { NgForm } from '@angular/forms';
import { ActivatedRoute } from '@angular/router';
import { of, throwError } from 'rxjs';
import { AnimationService } from 'src/app/Shared/services/animation/animation.service';
import { UserService } from 'src/app/Shared/services/user-service/user.service';

import { ProfileComponent } from './profile.component';

describe('ProfileComponent', () => {
  let component: ProfileComponent; // <-- Reference to component class (access/change properties, call methods, etc.)
  let fixture: ComponentFixture<ProfileComponent>; // <-- This is the parent of the component class (contains component, debugElement(html template), etc.). We don't need to test html template bindings.
  // Mock UserService (getUser method)
  // We are only using 'getUser' in this component
  let userServiceSpy: {
    getUser: jasmine.Spy,
    getProfile: jasmine.Spy,
    followUser: jasmine.Spy,
    unfollowUser: jasmine.Spy,
    isFollowing: jasmine.Spy
  };
  let activatedRouteSpy: any;
  let animationServiceSpy: { fadeIn: jasmine.Spy };
  const aRouteId: string = "4";

  // Spin up Test Module (Notice this is async because of line 28)
  beforeEach(async () => {
    // Initialize the spy before each test & before we inject it in our test module. (If we don't do this some stats that are kept track of, i.e. method invocation count will not be reset each test)
    // Second param is an array of method identifiers you wish to instantiate as spies.
    userServiceSpy = jasmine.createSpyObj('UserService', ['getUser', 'getProfile', 'followUser', "unfollowUser", 'isFollowing']);
    animationServiceSpy = jasmine.createSpyObj('AnimationServiceSpy', ['fadeIn']);
    activatedRouteSpy = { snapshot: { paramMap: { get: (name: string) => {return 'name'}} } };

    await TestBed.configureTestingModule({
      declarations: [ ProfileComponent ],
      // When the component tries to grab the UserService it will be grabbing our spy object instead
      providers: [
        { provide: UserService, useValue: userServiceSpy },
        { provide: ActivatedRoute, useValue: activatedRouteSpy },
        { provide: AnimationService, useValue: animationServiceSpy }
      ]
    })
    .compileComponents();
    spyOn(activatedRouteSpy.snapshot.paramMap, 'get').and.returnValue(aRouteId);
  });

  //Test environment is set up. Additional before each statements here.
  beforeEach(() => {
    fixture = TestBed.createComponent(ProfileComponent);
    component = fixture.componentInstance;
    // ngOnInit() is executed here (line below). Mock any functionality located within that method before this
    // fixture.detectChanges(); // <-- If you were integration testing the html template this would update bindings in html to reflect component values
  });

  // Define Test
  it('should create', () => {
    // Smoke test (Automatically generated by cli)
    expect(component).toBeTruthy();
  });

  // Define Test
  it('closeModal should remove "openScreen" class from screen element', () => {
    // Arrange
    // Parameter passed into method on act
    const modalTypeToPassIn: string = "test";
    // HTMl element
    const screenElement = document.createElement('div');

    // Return element from method ( when(document.getElementById(any())).thenReturn(screenElement) )
    spyOn(document, 'getElementById').and.returnValue(screenElement);
    // When screenElement.classList.remove() is called, invoke our supplied function instead (here do nothing)
    spyOn(screenElement.classList, 'remove').and.callFake(function() {});

    // Act
    component.closeModal(modalTypeToPassIn);

    // Assert
    // Notice in expect it is a reference to the mocked method, it is not invoked (No "()")
    expect(document.getElementById).toHaveBeenCalledWith('screen');
    expect(screenElement.classList.remove).toHaveBeenCalledWith('openScreen');
  });

  // Define Test
  it('closeModal should remove "openModal" class from modal element', () => {
    // Arrange
    // Parameter passed into method on act
    const modalTypeToPassIn: string = "test";
    // HTMl element
    const modalElement = document.createElement('div');

    // Return element from method ( when(document.getElementById(any())).thenReturn(modalElement) )
    spyOn(document, 'getElementById').and.returnValue(modalElement);
    // When screenElement.classList.remove() is called, invoke our supplied function instead (here do nothing)
    spyOn(modalElement.classList, 'remove').and.callFake(function() {});

    // Act
    component.closeModal(modalTypeToPassIn);

    // Assert
    // Notice in expect it is a reference to the spied on method, it is not invoked (No "()")
    expect(document.getElementById).toHaveBeenCalledWith('test-modal');
    expect(modalElement.classList.remove).toHaveBeenCalledWith('openModal');
  });

  it('openModal should add "openScreen" class to screen element', () => {
    // Arrange
    const modalTypeToPassIn: string = "test";
    const dataToPassIn: any = "testData";
    const screen = document.createElement('div');

    spyOn(document, 'getElementById').and.returnValue(screen);
    spyOn(screen.classList, 'add').and.callFake(function() {});

    // Act
    component.openModal(modalTypeToPassIn, dataToPassIn);

    // Assert
    expect(document.getElementById).toHaveBeenCalledWith('screen');
    expect(screen.classList.add).toHaveBeenCalledWith('openScreen');
  });

  it('openModal should add "openModal" class to modal element', () => {
    // Arrange
    const modalTypeToPassIn: string = "test";
    const dataToPassIn: any = "testData";
    const modal = document.createElement('div');

    spyOn(document, 'getElementById').and.returnValue(modal);
    spyOn(modal.classList, 'add').and.callFake(function() {});

    // Act
    component.openModal(modalTypeToPassIn, dataToPassIn);

    // Assert
    expect(document.getElementById).toHaveBeenCalledWith('test-modal');
    expect(modal.classList.add).toHaveBeenCalledWith('openModal');
  });

  // Define Test
  it('ngOnInit should load in user data', () => {
    // Arrange
    spyOn(component, 'getUserData');
    spyOn(component, 'getCurrentUserData');
    spyOn(component, 'openingAnimation');
    spyOn(component, 'isFollowing');

    // Act
    // Call ngOnInit()
    component.ngOnInit();

    // Assert
    expect(component.getCurrentUserData).toHaveBeenCalledTimes(1);
    expect(component.getUserData).toHaveBeenCalledTimes(1);
    expect(component.openingAnimation).toHaveBeenCalledTimes(1);
    expect(component.isFollowing).toHaveBeenCalledTimes(1);
  });

  // Define Test
  it('getCurrentUserData should update component user on success', () => {
    // Arrange
    // User that will be returned
    const user = {
      userId: 1,
      firstName: "John",
      lastName: "Doe"
    };
    // When userService.getUser method is called return our user as observable so that it can be subscribed to
    userServiceSpy.getUser.and.returnValue(of(user));

    // Act
    component.getCurrentUserData();

    // Assert
    expect(component.currentUser).toEqual(user);
  });

  // Define Test
  it('getCurrentUserData should log error on fail', () => {
    // Arrange
    // HttpErrorResponse to throw (I just included message cause that's all the component is using)
    const customHttpError: Partial<HttpErrorResponse> = {
      message: "This is the error message"
    };
    // When userService.getUser is called this will instead RETURN AN OBSERVABLE IN WHICH WILL THEN ERROR ON SUBSCRIBE with specified error (Notice 'throwError()' is a rxjs method. If you want to just throw an error from a method replace '.returnValue()' with '.throwError()')
    userServiceSpy.getUser.and.returnValue(throwError(() => customHttpError));
    // Spy on console.log so we can assert that it was called
    spyOn(console, 'log');

    // Act
    component.getCurrentUserData();

    // Assert
    expect(console.log).toHaveBeenCalledWith(customHttpError.message)
  });

  describe('#getUserData', () => {
    let response = { postsOwned: [{ post: "post1"}, { post: "post2"}], followers: [{}, {}, {}], following: [{}] };

    it('should set user correctly', fakeAsync(() => {
      userServiceSpy.getProfile.and.returnValue(of(response));

      component.getUserData();
      tick();

      expect(component.user).toEqual(response);
    }));
    it('should set posts correctly', fakeAsync(() => {
      userServiceSpy.getProfile.and.returnValue(of(response));

      component.getUserData();
      tick();

      expect(component.posts).toEqual(jasmine.arrayContaining(response.postsOwned));
    }));
    it('should set following/follower correctly', fakeAsync(() => {
      userServiceSpy.getProfile.and.returnValue(of(response));

      component.getUserData();
      tick();

      expect(component.followerLength).toEqual(response.followers.length);
      expect(component.followingLength).toEqual(response.following.length);
    }));
    it('should log error on ajax fail', fakeAsync(() => {
      const error = { message: "Error message" } as HttpErrorResponse;
      userServiceSpy.getProfile.and.returnValue(throwError(() => error));
      spyOn(console, 'log');

      component.getUserData();
      tick();

      expect(console.log).toHaveBeenCalledOnceWith(error.message);
    }));
  });

  describe('#closeAnyModal', () => {
    const div: HTMLElement = document.createElement('div');

    beforeEach(() => {
      spyOn(document, 'getElementById').and.returnValue(div);
      spyOn(div.classList, 'remove');
    });

    it('should remove openScreen class from screen element', () => {
      component.closeAnyModal();

      expect(document.getElementById).toHaveBeenCalledWith('screen')
      expect(div.classList.remove).toHaveBeenCalledWith('openScreen');
    });
    it('should remove openModal class from following-modal element', () => {
      component.closeAnyModal();

      expect(document.getElementById).toHaveBeenCalledWith('following-modal')
      expect(div.classList.remove).toHaveBeenCalledWith('openModal');
    });
    it('should remove openModal class from followers-modal element', () => {
      component.closeAnyModal();

      expect(document.getElementById).toHaveBeenCalledWith('followers-modal')
      expect(div.classList.remove).toHaveBeenCalledWith('openModal');
    });
  });

  it('#openingAnimation fades in main element', () => {
    component.openingAnimation();

    expect(animationServiceSpy.fadeIn).toHaveBeenCalledOnceWith('#profile', jasmine.any(Number), jasmine.any(Number), jasmine.any(Number));
  });

  describe('#followUser', () => {
    const followForm = { value: {
      followers: [{}, {}, {}]
      }
    } as NgForm;

    it('should set user data on successful response', fakeAsync(() => {
      userServiceSpy.followUser.and.returnValue(of(followForm.value));
      spyOn(component, 'getUserData');
      spyOn(component, 'isFollowing');

      component.followUser(followForm);
      tick();

      expect(component.followerLength).toEqual(followForm.value.followers.length);
      expect(component.getUserData).toHaveBeenCalledTimes(1);
      expect(component.isFollowing).toHaveBeenCalledTimes(1);
    }));

    it('should log error on failed response', fakeAsync(() => {
      const error = { message: "Error" } as HttpErrorResponse;
      userServiceSpy.followUser.and.returnValue(throwError(() => error));
      spyOn(console, 'log');

      component.followUser(followForm);
      tick();

      expect(console.log).toHaveBeenCalledOnceWith(error.message);
    }));
  });

  describe('#unfollowUser', () => {
    const followForm = { value: {
      followers: [{}, {}, {}]
      }
    } as NgForm;

    it('should set user data on successful response', fakeAsync(() => {
      userServiceSpy.unfollowUser.and.returnValue(of(followForm.value));
      spyOn(component, 'getUserData');
      spyOn(component, 'isFollowing');

      component.unfollowUser(followForm);
      tick();

      expect(component.followerLength).toEqual(followForm.value.followers.length);
      expect(component.getUserData).toHaveBeenCalledTimes(1);
      expect(component.isFollowing).toHaveBeenCalledTimes(1);
    }));

    it('should log error on failed response', fakeAsync(() => {
      const error = { message: "Error" } as HttpErrorResponse;
      userServiceSpy.unfollowUser.and.returnValue(throwError(() => error));
      spyOn(console, 'log');

      component.unfollowUser(followForm);
      tick();

      expect(console.log).toHaveBeenCalledWith(error.message);
    }));
  });

  describe('#isFollowing', () => {
    it('should set component.follow on successful response', fakeAsync(() => {
      userServiceSpy.isFollowing.and.returnValue(of({ data: "data" }));

      component.isFollowing();

      expect(component.follow).toEqual("data");
    }));

    it('should log error on failed response', fakeAsync(() => {
      const error = { message: "Error Message" } as HttpErrorResponse;
      userServiceSpy.isFollowing.and.returnValue(throwError(() => error));
      spyOn(console, 'log');

      component.isFollowing();

      expect(console.log).toHaveBeenCalledWith(error.message);
    }));
  });
});
